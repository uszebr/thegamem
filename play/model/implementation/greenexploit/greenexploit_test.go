package greenexploit

import (
	"fmt"
	"testing"

	"github.com/stretchr/testify/assert"
	"github.com/uszebr/thegamem/play/signal"
)

const (
	aproximateInteractions = 30
)

func TestIsAlwaysGreen(t *testing.T) {

	tests := []struct {
		opHistory []signal.Signal
		result    bool
	}{
		{opHistory: []signal.Signal{}, result: true},
		{opHistory: []signal.Signal{signal.Red}, result: false},
		{opHistory: []signal.Signal{signal.Green}, result: true},
		{opHistory: []signal.Signal{signal.Red, signal.Red}, result: false},
		{opHistory: []signal.Signal{signal.Green, signal.Red}, result: false},
		{opHistory: []signal.Signal{signal.Green, signal.Green}, result: true},
		{opHistory: []signal.Signal{signal.Red, signal.Green}, result: false},
		{opHistory: []signal.Signal{signal.Green, signal.Green, signal.Green}, result: true},
		{opHistory: []signal.Signal{signal.Green, signal.Green, signal.Green, signal.Green}, result: true},
		{opHistory: []signal.Signal{signal.Green, signal.Red, signal.Green, signal.Green}, result: false},
		{opHistory: []signal.Signal{signal.Green, signal.Green, signal.Green, signal.Green, signal.Green, signal.Green, signal.Green, signal.Green, signal.Green, signal.Green, signal.Green}, result: true},
		{opHistory: []signal.Signal{signal.Green, signal.Green, signal.Green, signal.Red, signal.Green, signal.Green, signal.Green, signal.Green, signal.Green, signal.Green, signal.Green}, result: false},
	}

	for index, testl := range tests {
		test := testl
		t.Run(fmt.Sprintf("Test: %v", index), func(t *testing.T) {
			actualResult := isAlwaysGreen(test.opHistory)
			assert.Equal(t, test.result, actualResult, "Test case %d failed", index)
		})
	}
}

func TestModelGreenExploit(t *testing.T) {

	tests := []struct {
		myHistory []signal.Signal
		opHistory []signal.Signal
		result    signal.Signal
	}{
		{myHistory: []signal.Signal{}, opHistory: []signal.Signal{}, result: signal.Green},
		// one signal in the histhory
		{myHistory: []signal.Signal{signal.Green}, opHistory: []signal.Signal{signal.Red}, result: signal.Red},
		{myHistory: []signal.Signal{signal.Green}, opHistory: []signal.Signal{signal.Green}, result: signal.Green},

		//two signal history
		{myHistory: []signal.Signal{signal.Green, signal.Green}, opHistory: []signal.Signal{signal.Green, signal.Red}, result: signal.Red},
		{myHistory: []signal.Signal{signal.Green, signal.Green}, opHistory: []signal.Signal{signal.Green, signal.Green}, result: signal.Green},
		//three
		{
			myHistory: []signal.Signal{signal.Green, signal.Green, signal.Green},
			opHistory: []signal.Signal{signal.Green, signal.Green, signal.Green},
			result:    signal.Red},
		{
			myHistory: []signal.Signal{signal.Green, signal.Green, signal.Red},
			opHistory: []signal.Signal{signal.Green, signal.Red, signal.Green},
			result:    signal.Green},

		// 	//five
		// 	{
		// 		myHistory: []signal.Signal{signal.Red, signal.Red, signal.Green, signal.Red, signal.Red},
		// 		opHistory: []signal.Signal{signal.Red, signal.Green, signal.Red, signal.Red, signal.Red},
		// 		result:    signal.Green},
		// 	//six
		// 	{
		// 		myHistory: []signal.Signal{signal.Red, signal.Red, signal.Green, signal.Red, signal.Red, signal.Red},
		// 		opHistory: []signal.Signal{signal.Green, signal.Green, signal.Green, signal.Green, signal.Green, signal.Green},
		// 		result:    signal.Green},

		// 	{
		// 		myHistory: []signal.Signal{signal.Red, signal.Red, signal.Green, signal.Red, signal.Red, signal.Red},
		// 		opHistory: []signal.Signal{signal.Red, signal.Red, signal.Red, signal.Red, signal.Red, signal.Red},
		// 		result:    signal.Red},
		// 	{
		// 		myHistory: []signal.Signal{signal.Red, signal.Red, signal.Green, signal.Red, signal.Red, signal.Red},
		// 		opHistory: []signal.Signal{signal.Green, signal.Red, signal.Green, signal.Green, signal.Red, signal.Red},
		// 		result:    signal.Green},
		// 	{
		// 		myHistory: []signal.Signal{signal.Red, signal.Red, signal.Green, signal.Red, signal.Red, signal.Red},
		// 		opHistory: []signal.Signal{signal.Red, signal.Red, signal.Green, signal.Green, signal.Red, signal.Red},
		// 		result:    signal.Red},

		// 	//seven
		// 	{
		// 		myHistory: []signal.Signal{signal.Red, signal.Red, signal.Green, signal.Red, signal.Red, signal.Red},
		// 		opHistory: []signal.Signal{signal.Green, signal.Green, signal.Green, signal.Green, signal.Green, signal.Green, signal.Green},
		// 		result:    signal.Green},

		// 	{
		// 		myHistory: []signal.Signal{signal.Red, signal.Red, signal.Green, signal.Red, signal.Red, signal.Red},
		// 		opHistory: []signal.Signal{signal.Red, signal.Red, signal.Red, signal.Red, signal.Red, signal.Red, signal.Green},
		// 		result:    signal.Red},
		// 	{
		// 		myHistory: []signal.Signal{signal.Red, signal.Red, signal.Green, signal.Red, signal.Red, signal.Red},
		// 		opHistory: []signal.Signal{signal.Green, signal.Red, signal.Green, signal.Green, signal.Red, signal.Red, signal.Green},
		// 		result:    signal.Green},
		// 	{
		// 		myHistory: []signal.Signal{signal.Red, signal.Red, signal.Green, signal.Red, signal.Red, signal.Red},
		// 		opHistory: []signal.Signal{signal.Red, signal.Red, signal.Green, signal.Green, signal.Red, signal.Red, signal.Green},
		// 		result:    signal.Red},
	}

	for index, testl := range tests {
		test := testl
		t.Run(fmt.Sprintf("Test: %v", index), func(t *testing.T) {
			model := ModGreenExploit{}.GetModel()
			actualResult := model.CalculateSignal(test.myHistory, test.opHistory, aproximateInteractions)
			assert.Equal(t, test.result, actualResult, "Test case %d failed", index)
		})
	}

}
